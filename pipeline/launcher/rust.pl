use strict;
use warnings;
use File::Path qw(remove_tree);
use File::Copy;
use File::Basename;

# load a Rust environment or compile pipeline Rust executables (for developers)

use vars qw($launcherDir $environmentsDir $config %optionArrays 
            $pipelineSuite $pipelineName $pipelineSuiteDir $pipelineDir $suiteBinDir);

#------------------------------------------------------------------------------
# create a versioned Rust development environment
#------------------------------------------------------------------------------
sub createRustEnvironment {
    my ($rustVersion) = @_;
    my $cnd = getRustCondaPaths($rustVersion);

    # check for the existence of the environment; create it if missing
    if ( -f $$cnd{showFile} ) {
        print "Rust environment already exists at $$cnd{dir}\n";
        system("cat $$cnd{showFile}");
    } else {
        open my $outH, ">", $$cnd{initFile} or throwError("could not write to $$cnd{initFile}: $!");
        print $outH "# created by mdi-pipelines-framework/pipeline/launcher/rust.pl\n";
        print $outH "---\n";
        print $outH "channels:\n";
        print $outH "  - conda-forge\n";
        print $outH "dependencies:\n";
        print $outH "  - rust=$rustVersion\n"; # rustc and cargo    
        print $outH "  - rust-src=$rustVersion\n";
        # print $outH "  - compilers\n";
        # print $outH "  - pkg-config\n";
        # print $outH "  - gcc_linux-64\n";
        # print $outH "  - gxx_linux-64\n";
        close $outH;
        my $condaCommand = "env create --prefix $$cnd{dir} --file $$cnd{initFile}";
        my $bash = 
"bash -c '
$$cnd{loadCommand}
source $$cnd{profileScript}
conda $condaCommand
'";
        print "executing command sequence: $bash\n";
        if(system($bash)){
            remove_tree $$cnd{dir};
            unlink $$cnd{initFile}; 
            throwError("rust load failed to create the conda environment\n");
        }
        move($$cnd{initFile}, $$cnd{showFile});
    }
    releaseMdiGitLock();
}

#------------------------------------------------------------------------------
# execute a command in the Rust development environment
#------------------------------------------------------------------------------
sub execRustEnvironment {
    my ($rustVersion, @args) = @_;
    my $cnd = getRustCondaPaths($rustVersion);

    # check for the existence of the environment
    if (! -f $$cnd{showFile} ) {
        throwError("Rust environment does not exist at $$cnd{dir}\n".
                   "Please create it first with:\n    mdi $pipelineName rust --create $rustVersion\n");
    }

    # load the environment
    my $scriptFile = glob("~/.mdi.shellFile");
    my $script = join("\n",
        "rm -f $scriptFile", # the script file deletes itself
        $$cnd{loadCommand},
        "source $$cnd{profileScript}",
        "conda activate $$cnd{dir}"
    )."\n";
    $script .= "exec ".join(" ", @args)."\n";
    $script =~ s/\r//g;
    my $shellCommand = "bash $scriptFile";
    open my $outH, ">", $scriptFile or throwError("could not write to $scriptFile: $!");
    print $outH $script; 
    close $outH;
    releaseMdiGitLock();
    exec $shellCommand;
}

#------------------------------------------------------------------------------
# generate rust-analyzer startup script for VSCode integration
#------------------------------------------------------------------------------
sub generateRustAnalyzerScript {
    my ($rustVersion, $gccLoadCommand) = @_;
    my $cnd = getRustCondaPaths($rustVersion);

    # initalize the bash script
    my $scriptFile = "$ENV{HOME}/rust-setup.sh";
    open my $outH, ">", $scriptFile or throwError("could not write to $scriptFile: $!");
    print $outH "#!/bin/bash\n";
    print $outH "\n# generated by mdi-pipelines-framework/pipeline/launcher/rust.pl\n";
    print $outH "\n# creates a rust-analyzer launch wrapper for versioned Rust environments in VS Code\n";
    print $outH "\n# override system rust commands to the versioned environment\n";
    print $outH "export PATH=$$cnd{dir}/bin:\$PATH\n";
    if ($gccLoadCommand) { # load GCC environment for Rust C compilation
        print $outH "\n# load GCC environment for Rust C compilation\n";
        print $outH "$gccLoadCommand\n";
    }
    print $outH "\n# find and execute the call to VS Code rust-analyzer extension\n";
    print $outH "RUST_ANALYZER_DIR=`ls -1dr /\$HOME/.vscode-server/extensions/rust-lang.rust-analyzer* | head -n 1`\n";
    print $outH "RUST_ANALYZER=`echo \"\$RUST_ANALYZER_DIR/server/rust-analyzer\"`\n";
    print $outH "exec \$RUST_ANALYZER \"\$@\"\n"; 
    close $outH;
    chmod 0755, $scriptFile or throwError("could not set execute permissions on $scriptFile: $!");
    print "generated rust-analyzer startup script for VSCode at:\n    $scriptFile\n\n";
    system("cat $scriptFile");
    releaseMdiGitLock();
}

#------------------------------------------------------------------------------
# compile Rust crates listed as crate root directories in 'pipelines/$pipelineName/rust.txt'
# executable targets are copied into directory '$MDI_DIR/bin/<pipeline_suite>/<pipeline_name>/<target_name>'
#------------------------------------------------------------------------------
sub compileRustExecutables {
    my ($rustVersion, $gccLoadCommand, $noConda) = @_;

    # initalize the bash script
    my $script;
    if (!$noConda){
        my $cnd = getRustCondaPaths($rustVersion);
        if ( ! -f $$cnd{showFile} ) {
            throwError("Rust environment does not exist at $$cnd{dir}\n".
                    "Please create it first with:\n    mdi $pipelineName rust --create $rustVersion\n");
        }
        $script = join("\n",
            $$cnd{loadCommand},
            "source $$cnd{profileScript}",
            "conda activate $$cnd{dir}",
        )."\n";
    }
    $script .= join("\n",
        $gccLoadCommand ? $gccLoadCommand : "", # use the --gcc option to load a GCC environment for C linking
        "export RUSTFLAGS=\"-C linker=gcc\""    # ensure system gcc is used for C linking to avoid conda gcc issues
    )."\n";

    # iterate through each Rust crate defined for the tool suite containing the index pipeline
    my $rustFile = "$pipelineSuiteDir/rust.txt";
    -f $rustFile or throwError("no Rust crate definitions found for suite '$pipelineSuite' at:\n    $rustFile");
    open my $inH, "<", $rustFile or throwError("could not read $rustFile: $!");
    while (my $cratePath = <$inH>) {
        chomp $cratePath;
        $cratePath =~ s/#.*$//; # remove comments
        $cratePath =~ s/^\s+|\s+$//g; # trim whitespace
        next if !$cratePath; # skip blank lines
        my $targetName = basename($cratePath);
        my $script = $script;
        $script .= "cd $pipelineSuiteDir/$cratePath\n"; # crate paths are relative to pipeline suite directory
        $script .= "cargo build --release --bin $targetName\n";
        $script .= "mkdir -p $suiteBinDir\n";
        $script .= "cp -f target/release/$targetName $suiteBinDir/$targetName\n";
        my $bash = "bash -c '\n$script\n'";
        print "executing command sequence: $bash\n";
        if(system($bash)){
            throwError("rust compile failed for crate at:\n    $pipelineSuiteDir/$cratePath\n");
        }
    }
    close $inH;
    releaseMdiGitLock();
}

#------------------------------------------------------------------------------
# shared rust support, analogous to conda::getCondaPaths
#------------------------------------------------------------------------------
sub getRustCondaPaths {
    my ($rustVersion) = @_;
    
    # check the path where environments are installed
    my $mdiDir = $ENV{MDI_DIR};
    my $baseDir = "$mdiDir/environments";
    -d $baseDir or throwError("conda directory does not exist:\n    $baseDir");
    
    # establish the proper name for the environment
    my ($envName, $envType) = ("rust-$rustVersion", "named");

    # set environment paths
    my $envDir   = "$baseDir/$envName";
    my $initFile = "$baseDir/$envName.yml"; # used to create the environment
    my $showFile = "$envDir/$envName.yml";  # permanent store to show what was created
    
    # locate the script that must be sourced to allow 'conda activate' to be called from scripts
    # see: https://github.com/conda/conda/issues/7980
    my $configYmlFile = "$mdiDir/config/stage1-pipelines.yml";
    my $configYml = loadOptionsConfigFile($configYmlFile, 1);
    $configYml = mergeYAML($configYml);
    $$configYml{variables} = mergeYamlVariables($configYmlFile);
    my $loadCommand = applyVariablesToYamlValue($$configYml{conda}{'load-command'}[0], \%ENV);
    my $profileScript = applyVariablesToYamlValue($$configYml{conda}{'profile-script'}[0], \%ENV);
    if(!$profileScript or $profileScript eq 'null'){
        my $loadCommand = $loadCommand ? $loadCommand : "echo";
        my $condaBasePath = qx|$loadCommand 1>/dev/null 2>/dev/null; conda info --base|;
        chomp $condaBasePath;
        $profileScript = "$condaBasePath/etc/profile.d/conda.sh";
    }
    
    # determine if the server requires us to load conda (if not, it must be always available)
    if(!$loadCommand or $loadCommand eq 'null'){
        $loadCommand = "# using system conda";
    }
    
    # return our conda details
    {
        baseDir       => $baseDir,
        dir           => $envDir,
        initFile      => $initFile,
        showFile      => $showFile,
        name          => $envName,
        type          => $envType,
        profileScript => $profileScript,
        loadCommand   => $loadCommand,
    }
}

1;
